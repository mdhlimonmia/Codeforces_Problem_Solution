{
    "C++ Competitive Programming Template": {
        "prefix": "cpp",
        "body": [
            "///   ***   ---   |||    In the name of ALLAH    |||   ---   ***   ///",
            "",
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "typedef vector<int> vi;",
            "typedef vector<ll> vl;",
            "typedef vector<vi> vvi;",
            "typedef vector<vl> vvl;",
            "typedef pair<int,int> pii;",
            "typedef pair<double, double> pdd;",
            "typedef pair<ll, ll> pll;",
            "typedef vector<pii> vii;",
            "typedef vector<pll> vll;",
            "typedef double dl;",
            "",
            "#define endl '\\n'",
            "#define PB push_back",
            "#define F first",
            "#define S second",
            "#define all(a) (a).begin(),(a).end()",
            "#define rall(a) (a).rbegin(),(a).rend()",
            "#define sz(x) (int)x.size()",
            "#define yes cout<<\"YES\"<<endl",
            "#define no cout<<\"NO\"<<endl",
            "#define POPCOUNT __builtin_popcountll /*number of set bit*/",
            "#define RIGHTMOST __builtin_ctzll",
            "#define LEFTMOST(x) (63-__builtin_clzll((x)))",
            "",
            "const double PI = acos(-1);",
            "const double eps = 1e-9;",
            "const int inf = 2000000000;",
            "const ll infLL = 9000000000000000000;",
            "#define MOD 1000000007",
            "",
            "#define mem(a,b) memset(a, b, sizeof(a) )",
            "#define sqr(a) ((a) * (a))",
            "",
            "#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
            "#define fraction() cout.unsetf(ios::floatfield); cout.precision(10); cout.setf(ios::fixed,ios::floatfield);",
            "#define file() freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);",
            "//",
            "//debug",
            "template<typename F,typename S>ostream&operator<<(ostream&os,const pair<F,S>&p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}",
            "template<typename T>ostream&operator<<(ostream&os,const vector<T>&v){os<<\"{\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"}\";}",
            "template<typename T>ostream&operator<<(ostream&os,const set<T>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\",\";os<<*it;}return os<<\"]\";}",
            "template<typename T>ostream&operator<<(ostream&os,const multiset<T>&v) {os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"]\";}",
            "template<typename F,typename S>ostream&operator<<(ostream&os,const map<F,S>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<it->first<<\" = \"<<it->second;}return os<<\"]\";}",
            "#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)",
            "void faltu(){cerr << endl;}",
            "template<typename T>void faltu(T a[],int n){for(int i=0;i<n;++i)cerr<<a[i]<<' ';cerr<<endl;}",
            "template<typename T,typename...hello>void faltu(T arg,const hello&...rest){cerr<<arg<<' ';faltu(rest...);}",
            "",
            "ll gcd ( ll a, ll b ) { return __gcd ( a, b ); }",
            "ll lcm ( ll a, ll b ) { return a * ( b / gcd ( a, b ) ); }",
            "ll getSetBit(ll x) {return __builtin_popcount(x);};",
            "",
            "int dx[] = { 0, 0, +1, -1, -1  +1, -1, +1 };",
            "int dy[] = { +1, -1, 0, 0, -1, +1, +1, -1 };",
            "",
            "inline void normal(ll &a) { a %= MOD; (a < 0) && (a += MOD); }",
            "inline ll modMul(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a*b)%MOD; }",
            "inline ll modAdd(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); return (a+b)%MOD; }",
            "inline ll modSub(ll a, ll b) { a %= MOD, b %= MOD; normal(a), normal(b); a -= b; normal(a); return a; }",
            "inline ll modPow(ll b, ll p) { ll r = 1; while(p) { if(p&1) r = modMul(r, b); b = modMul(b, b); p >>= 1; } return r; }",
            "inline ll modInverse(ll a) { return modPow(a, MOD-2); }",
            "inline ll modDiv(ll a, ll b) { return modMul(a, modInverse(b)); }",
            "",
            "const int mx = 1e5+123;",
            "",
            "void solve(){",
            "    ll n;cin>>n;",
            "}",
            "",
            "int main()",
            "{",
            "    optimize();",
            "",
            "    int _ = 1;",
            "    cin>>_;",
            "    for (int tc = 1; tc<=_; tc++)",
            "    {",
            "        //cout<<\"Case \"<<tc<<\": \";",
            "        solve();",
            "    }",
            "}"
        ],
        "description": "C++ Competitive Programming Template"
    },
    "Yes and No": {
        "prefix": "nos",
        "body": [
            "if(1){",
            "    cout<<\"YES\"<<endl;",
            "}else{",
            "    cout<<\"NO\"<<endl;",
            "}"
        ],
        "description": "C++ Yes No print"
    },
    "Dijkstra Algorithm": {
        "prefix": "dijkstra",
        "body": [
            "const int mx = 1e5+123;",
            "int n,m;",
            "vii adj[mx];",
            "vl dis(mx);",
            "",
            "void dijkstra(int s){",
            "    for(int i = 0; i<=n; i++) dis[i] = infLL;",
            "    priority_queue<pll, vll, greater<pll>> pq;",
            "    dis[s] = 0;",
            "    pq.push({0, s});",
            "    while (!pq.empty()) {",
            "        int u = pq.top().S;",
            "        ll curD = pq.top().F;",
            "        pq.pop();",
            "        if(curD > dis[u]) continue;",
            "        for (auto v: adj[u]) {",
            "            if(dis[v.F] > curD + v.S) {",
            "                dis[v.F] = curD + v.S;",
            "                pq.push({curD + v.S, v.F});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra's Algorithm using priority queue and adjacency list"
    },
    "Prime Generation Algorithm": {
        "prefix": "primeGen",
        "body": [
            "bitset<mx> isPrime;",
            "vector<int> primes;",
            "",
            "void primeGen(int n) {",
            "    for (int i = 3; i <= n; i += 2) isPrime[i] = 1;",
            "",
            "    int sq = sqrt(n);",
            "    for (int i = 3; i <= sq; i += 2) {",
            "        if (isPrime[i]) {",
            "            for (int j = i * i; j <= n; j += i) {",
            "                isPrime[j] = 0;",
            "            }",
            "        }",
            "    }",
            "",
            "    primes.push_back(2);",
            "    for (int i = 3; i <= n; i += 2) {",
            "        if (isPrime[i] == 1) {",
            "            primes.push_back(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Generate prime numbers up to n using the Sieve of Eratosthenes"
    },
    "isPrime": {
        "prefix": "isPrime",
        "body": [
            "bool isPrime(ll n) {",
            "    if (n <= 1)",
            "        return false;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (n % i == 0)",
            "            return false;",
            "    }",
            "    return true;",
            "}"
        ],
        "description": "Checks if a number is prime"
    },
    "numberOfDivisors": {
        "prefix": "numberOfDivisors",
        "body": [
            "ll numberOfDivisors(ll n) {",
            "    ll ans = 1;",
            "    for (auto u : primes) {",
            "        if (1ll * u * u > n) break;",
            "        if (n % u == 0) {",
            "            ll a = 0;",
            "            while (n % u == 0) {",
            "                a++;",
            "                n /= u;",
            "            }",
            "            ans *= (a + 1);",
            "        }",
            "    }",
            "    if (n != 1) {",
            "        ans *= 2;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Calculates the number of divisors of a given number using a list of primes"
    },
    "sum_of_Digit": {
        "prefix": "sum_of_Digit",
        "body": [
            "ll sum_of_Digit(ll x) {",
            "    ll sum = 0;",
            "    while (x) {",
            "        sum += (x % 10);",
            "        x /= 10;",
            "    }",
            "    return sum;",
            "}"
        ],
        "description": "Calculates the sum of digits of a number"
    },
    "Euler_Phi": {
        "prefix": "Euler_Phi",
        "body": [
            "ll Euler_Phi(ll n) {",
            "    ll phi = n;",
            "    for (auto u : primes) {",
            "        if (1ll * u * u > n) break;",
            "        if (n % u == 0) {",
            "            while (n % u == 0) {",
            "                n /= u;",
            "            }",
            "            phi /= u;",
            "            phi *= (u-1);",
            "        }",
            "    }",
            "    if (n != 1) {",
            "        phi /= n;",
            "        phi *= (n-1);",
            "    }",
            "    return phi;",
            "}"
        ],
        "description": "Calculates the Euler's Totient function for a given number"
    },
    "bigMod": {
        "prefix": "bigMod",
        "body": [
            "ll bigMod(ll base, ll pow, ll mod) {",
            "    if (pow == 0) return 1 % mod;",
            "    if (pow % 2 == 0) {",
            "        ll tem = bigMod(base, pow / 2, mod);",
            "        return (tem * tem) % mod;",
            "    } else {",
            "        return (base * bigMod(base, pow - 1, mod)) % mod;",
            "    }",
            "}"
        ],
        "description": "Calculates (base^pow) % mod efficiently using recursion"
    },
    "SOD": {
        "prefix": "SOD",
        "body": [
            "ll SOD(ll n) {",
            "    ll ans = 1;",
            "    for (auto u : primes) {",
            "        if (1ll * u * u > n) break;",
            "        if (n % u == 0) {",
            "            ll fa = 1, sum = 1;",
            "            while (n % u == 0) {",
            "                fa *= u;",
            "                sum += fa;",
            "                n /= u;",
            "            }",
            "            ans *= sum;",
            "        }",
            "    }",
            "    if (n != 1) {",
            "        ans *= (n + 1);",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Calculates the Sum of Divisors (SOD) of a number using its prime factorization"
    },
    "dfs_string": {
        "prefix": "dfs_string",
        "body": [
            "void dfs_string(int i, int j) {",
            "    vis[i][j] = 1;",
            "    for (int k = 0; k < 4; k++) {",
            "        int x = i + dx[k];",
            "        int y = j + dy[k];",
            "        if (x >= 0 && y >= 0 && x < n && y < m && vis[x][y] == 0 && adj[x][y] == '1') {",
            "            dfs_string(x, y);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Performs depth-first search (DFS) for a 2D grid of strings, marking connected components."
    },
    "Euler_Phi_Sive": {
        "prefix": "Euler_Phi_Sive",
        "body": [
            "const int mx = 5000123;",
            "vi phi(mx);",
            "vector<ull> sumPhi(mx);",
            "void Euler_Phi_Sive() {",
            "    for (int i = 1; i < mx; i++) phi[i] = i;",
            "    for (int i = 2; i < mx; i++) {",
            "        if (phi[i] == i) {",
            "            for (int j = i; j < mx; j += i) {",
            "                phi[j] -= phi[j] / i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Precomputes Euler's Totient function (phi array) for all integers up to mx."
    },
    "KMP String Search": {
        "prefix": "kmp_search",
        "body": [
            "/*KMP String Search Algorithm to find occurrences of B in A.*/",
            "void genLPSArray(vi &lps, string &s, int m){",
            "    int len = 0, i = 1;",
            "    while(i < m){",
            "        if(s[i] == s[len]){",
            "            len++;",
            "            lps[i] = len;",
            "            i++;",
            "        }else{",
            "            if(len != 0){",
            "                len = lps[len-1];",
            "            }else{",
            "                lps[i] = 0;",
            "                i++;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "ll KMPSearch(string &a, ll n, string &b, ll m){",
            "    vi lps(m, 0);",
            "    genLPSArray(lps, b, m);",
            "    ll i = 0, j = 0, total = 0;",
            "    while(i < n){",
            "        if(a[i] == b[j]){",
            "            i++, j++;",
            "        }",
            "        if(j == m){",
            "            total++;",
            "            j = lps[j-1];",
            "        }else if(i < n && a[i] != b[j]){",
            "            if(j != 0){",
            "                j = lps[j-1];",
            "            }else{",
            "                i++;",
            "            }",
            "        }",
            "    }",
            "    return total;",
            "}"
        ],
        "description": "KMP String Search Algorithm to find occurrences of B in A."
    },
    "Bellman-Ford Algorithm": {
        "prefix": "bellmanFord",
        "body": [
            "struct info {",
            "    ll u, v, w;",
            "};",
            "vector<info> e;",
            "ll dis[mx];",
            "",
            "bool bellmanFord(ll s, ll n, ll m) {",
            "    for (int i = 0; i <= n; i++) dis[i] = inf;",
            "    dis[s] = 0;",
            "    bool isCycle = false;",
            "    for (int i = 1; i <= n; i++) {",
            "        isCycle = false;",
            "        for (int j = 0; j < m; j++) {",
            "            ll u = e[j].u, v = e[j].v, w = e[j].w;",
            "            //if(dis[u]<inf){",
            "               if (dis[u]<inf && dis[u] + w < dis[v]) {",
            "                   dis[v] = max(-infLL, dis[u] + w);",
            "                   isCycle = true;",
            "               }",
            "           //}",
            "        }",
            "    }",
            "    return isCycle;",
            "}",
            "",
            "void solve() {",
            "    ll n, m;",
            "    cin >> n >> m;",
            "    e.clear();",
            "    ll u, v, w;",
            "    for (int i = 0; i < m; i++) {",
            "        cin >> u >> v >> w;",
            "        e.push_back({u, v, w});",
            "    }",
            "    if (bellmanFord(0, n, m))",
            "        cout << \"There is a Negative Cycle\\n\";",
            "    else",
            "        cout << \"No Negative Cycle\\n\";",
            "}"
        ],
        "description": "Bellman-Ford Algorithm for detecting negative cycles."
    },
    "Floyd-Warshall Algorithm": {
        "prefix": "floydWarshall",
        "body": [
            "const int mx = 1e3+123;",
            "ll adj[mx][mx];",
            "",
            "// Find shortest path in all pairs",
            "void floydWarshall(int n) {",
            "    for (int k = 1; k <= n; k++) {",
            "        for (int i = 1; i <= n; i++) {",
            "            for (int j = 1; j <= n; j++) {",
            "                if (adj[i][k] + adj[k][j] < adj[i][j]) {",
            "                    adj[i][j] = adj[i][k] + adj[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "void solve() {",
            "    ll n, m;",
            "    cin >> n >> m;",
            "    for (int i = 0; i <= n; i++) {",
            "        for (int j = 0; j <= n; j++) {",
            "            if (i != j) adj[i][j] = infLL;",
            "        }",
            "    }",
            "",
            "    for (int i = 1; i <= m; i++) {",
            "        ll u, v, w;",
            "        cin >> u >> v >> w;",
            "        adj[u][v] = min(adj[u][v], w);",
            "        //adj[v][u] = min(adj[v][u], w); // Bidirectional",
            "    }",
            "    floydWarshall(n);",
            "",
            "    for (int i = 1; i <= n; i++) {",
            "        for (int j = 1; j <= n; j++) {",
            "            if (adj[i][j] != infLL) cout << adj[i][j] << \" \";",
            "            else cout << \"inf \";",
            "        }",
            "        cout << endl;",
            "    }",
            "}"
        ],
        "description": "Floyd-Warshall Algorithm for All-Pairs Shortest Path"
    },
    "nCr Function (Binomial Coefficient)": {
        "prefix": "nCr",
        "body": [
        "ll nCr(int n, int r) {",
        "    if (r > n) return 0;",
        "    if (r > n - r) r = n - r; // C(n, r) == C(n, n - r)",
        "    ll res = 1;",
        "    for (int i = 1; i <= r; ++i) {",
        "        res *= (n - r + i);",
        "        res /= i;",
        "    }",
        "    return res;",
        "}"
        ],
        "description": "Calculates C(n, r) using an efficient iterative method"
    },
    "Calculate Number of Sub-squares Covering a Cell": {
        "prefix": "cal_nssccell",
        "body": [
        "// number of sub-squares(KxK) that cover the cell(i,j)",
        "ll cal_nssccell(ll i, ll j, ll k){",
        "    return (min(i,n-k)-max(-1LL,i-k))*(min(j,m-k)-max(-1LL,j-k));",
        "}"
        ],
        "description": "Returns number of k×k sub-squares covering cell (i, j) in an n×m grid"
    },
    "Cycle Detection in Undirected Graph (DFS)": {
        "prefix": "isCycle",
        "body": [
        "//Call isCycle(source, -1)",
        "bool isCycle(ll s, ll parent){",
        "    vis[s] = 1;",
        "    for(auto u : adj[s]){",
        "        if(vis[u] == 1 && parent != u){",
        "            return 1;",
        "        }else if(vis[u] == 0){",
        "            if(isCycle(u, s)) return 1;",
        "        }",
        "    }",
        "    return 0;",
        "}"
        ],
        "description": "Detects cycle in an undirected graph using DFS"
    },
     "Segment Tree Class (Customizable Lazy)": {
        "prefix": "segmentTree",
        "body": [
        "class SGT{",
        "    //*** must update the marge section",
        "    ll marge(ll left, ll right){",
        "        ll ans;",
        "        ans = min(left,right);",
        "        return ans;",
        "    }",
        "    //*** Must update lazy lection",
        "    void upLazy(ll id, ll b, ll e){",
        "        tree[id] += lazy[id];",
        "        if(b!=e){",
        "            lazy[id*2]+=lazy[id];",
        "            lazy[id*2+1]+=lazy[id];",
        "        }",
        "        lazy[id] = 0;",
        "    }",
        "    public:",
        "        vl tree, lazy;",
        "        //***must update this section",
        "        SGT(ll n){",
        "            tree.resize(n*4);// resize segment tree;",
        "            lazy.resize(n*4);//resize lazy tree;",
        "        }",
        "        //build segment tree",
        "        void build(ll id, ll b, ll e, ll arr[]){",
        "            if(b == e){",
        "                tree[id] = arr[b];",
        "                return;",
        "            }",
        "            ll mid = (b+e)>>1, l = id<<1, r = l|1;",
        "            build(l, b, mid, arr);",
        "            build(r, mid+1, e, arr);",
        "            tree[id] = marge(tree[l], tree[r]);",
        "        }",
        "        //update segment tree",
        "        void update(ll id, ll b, ll e, ll x, ll y, ll v){",
        "            //*** if have lazy tree",
        "            if(lazy[id] != 0){",
        "                upLazy(id, b, e);",
        "            }",
        "            if(x>e || y<b)return;",
        "            if(b>=x && e<=y){",
        "                lazy[id] = v;",
        "                upLazy(id, b, e); //*** If lazy tree",
        "                return;",
        "            }",
        "            ll mid = (b+e)>>1, l = id<<1, r = l|1;",
        "            update(l, b, mid, x, y, v);",
        "            update(r, mid+1, e, x, y, v);",
        "            tree[id] = marge(tree[l], tree[r]);",
        "        }",
        "        //quary section",
        "        ll ask(ll id, ll b, ll e, ll x, ll y){",
        "            if(lazy[id] != 0) upLazy(id, b, e); // *** if have lazy tree otherwise remove it",
        "            if(x>e || y<b)return infLL; //*** Must update return value",
        "            if(b>=x && e<=y){",
        "                return tree[id];",
        "            }",
        "            ll mid = (b+e)>>1, l = id<<1, r = l|1;",
        "            ll left = ask(l, b, mid, x, y);",
        "            ll right = ask(r, mid+1, e, x, y);",
        "            return marge(left, right);",
        "        }",
        "};"
        ],
        "description": "Segment Tree class with customizable lazy propagation (no changes applied)"
    },
    "Disjoint Set Union (DSU)": {
        "prefix": "dsu",
        "body": [
        "/* To get number of different sets - count non-zero elements in siz or use set of leaders.",
        "   Clear parent and siz if DSU is reused. */",
        "",
        "// Disjoint Set Union",
        "ll parent[mxN]; // or use: map<ll,ll> parent;",
        "ll siz[mxN];    // or use: map<ll,ll> siz;",
        "",
        "void make_set(ll v) {",
        "    parent[v] = v;",
        "    siz[v] = 1;",
        "}",
        "",
        "ll find_set(ll v) {",
        "    return (v == parent[v]) ? v : parent[v] = find_set(parent[v]);",
        "}",
        "",
        "void union_sets(ll a, ll b) {",
        "    a = find_set(a);",
        "    b = find_set(b);",
        "    if (a == b) return;",
        "    if (siz[a] < siz[b]) swap(a, b);",
        "    parent[b] = a;",
        "    siz[a] += siz[b];",
        "    siz[b] = 0; // siz.erase(b); if using map",
        "}"
        ],
        "description": "Disjoint Set Union (Union-Find) with size and path compression"
    },
    "Longest Common Substring (actual string)": {
        "prefix": "longestCommonSubstr",
        "body": [
        "/*ans is length of longest Common Sub-string and s is the Substring.*/",
        "int dp[1005][1005];",
        "string longestCommonSubstr(string& s1, string& s2) {",
        "    memset(dp, 0, sizeof(dp));",
        "    int ans = 0, x = 0, y = 0;",
        "    for(int i = 1; i <= s1.size(); i++) {",
        "        for(int j = 1; j <= s2.size(); j++) {",
        "            if(s1[i - 1] == s2[j - 1]) {",
        "                dp[i][j] = 1 + dp[i - 1][j - 1];",
        "                if(dp[i][j] > ans) {",
        "                    ans = dp[i][j];",
        "                    x = i - 1;",
        "                }",
        "            }",
        "        }",
        "    }",
        "    string s = \"\";",
        "    while(ans > 0) {",
        "        s += s1[x];",
        "        x--;",
        "        ans--;",
        "    }",
        "    reverse(s.begin(), s.end());",
        "    return s;",
        "}"
        ],
        "description": "Returns the actual Longest Common Substring between two strings"
    },
    "Longest Common Subsequence Function": {
        "prefix": "longest_common_sub_sequence",
        "body": [
        "int dp[1000][1000];",
        "string a, b;",
        "int n, m;",
        "int longest_common_sub_sequence(int i, int j) {", 
        "    if (i >= n || j >= m) return 0;",
        "    if (dp[i][j] != -1) return dp[i][j];",
        "    int res;",
        "    if (a[i] == b[j]) {",
        "        res = longest_common_sub_sequence(i + 1, j + 1) + 1;",
        "    } else {",
        "        res = max(longest_common_sub_sequence(i, j + 1), longest_common_sub_sequence(i + 1, j));",
        "    }",
        "    return dp[i][j] = res;",
        "}"
        ],
        "description": "Function to calculate the length of the longest common subsequence using recursion and memoization."
    },
    "For Loop": {
        "prefix": "loop",
        "body": [
            "for(ll ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {",
            "    ${3:// code here}",
            "}"
        ],
        "description": "Basic for loop from 0 to n-1"
    }

}